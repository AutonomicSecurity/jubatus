// this program is automatically generated by jenerator. do not edit.
#include "../framework.hpp"
#include "graph_server.hpp"
#include "graph_serv.hpp"
using namespace jubatus;
using namespace jubatus::framework;
#define RETURN_OR_THROW(f) try { \
  return f; \
} catch (const jubatus::exception::jubatus_exception& e) { \
  LOG(WARNING) << e.diagnostic_information(true); \
  throw; \
} catch (const std::exception& e) { \
  LOG(ERROR) << e.what(); \
  throw; \
}
namespace jubatus { namespace server {
class graph_impl_ : public graph<graph_impl_>
{
public:
  graph_impl_(const server_argv& a):
    graph<graph_impl_>(a.timeout),
    p_(new server_helper<graph_serv>(a, true))
  {}

  std::string create_node(std::string name) //nolock random
  { NOLOCK__(p_); RETURN_OR_THROW(get_p()->create_node()); }

  int remove_node(std::string name, std::string nid) //update cht(2)
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->remove_node(nid)); }

  int update_node(std::string name, std::string nid, property p) //update cht(2)
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->update_node(nid, p)); }

  unsigned long create_edge(std::string name, std::string nid, edge_info ei) //nolock cht(1)
  { NOLOCK__(p_); RETURN_OR_THROW(get_p()->create_edge(nid, ei)); }

  int update_edge(std::string name, std::string nid, unsigned long eid, edge_info ei) //update cht(2)
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->update_edge(nid, eid, ei)); }

  int remove_edge(std::string name, std::string nid, unsigned long e) //update cht(2)
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->remove_edge(nid, e)); }

  double centrality(std::string name, std::string nid, int ct, preset_query q) //analysis random
  { JRLOCK__(p_); RETURN_OR_THROW(get_p()->centrality(nid, ct, q)); }

  bool add_centrality_query(std::string name, preset_query q) //update broadcast
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->add_centrality_query(q)); }

  bool add_shortest_path_query(std::string name, preset_query q) //update broadcast
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->add_shortest_path_query(q)); }

  bool remove_centrality_query(std::string name, preset_query q) //update broadcast
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->remove_centrality_query(q)); }

  bool remove_shortest_path_query(std::string name, preset_query q) //update broadcast
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->remove_shortest_path_query(q)); }

  std::vector<std::string > shortest_path(std::string name, shortest_path_req r) //analysis random
  { JRLOCK__(p_); RETURN_OR_THROW(get_p()->shortest_path(r)); }

  int update_index(std::string name) //update broadcast
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->update_index()); }

  int clear(std::string name) //update broadcast
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->clear()); }

  node_info get_node(std::string name, std::string nid) //analysis cht(2)
  { JRLOCK__(p_); RETURN_OR_THROW(get_p()->get_node(nid)); }

  edge_info get_edge(std::string name, std::string nid, unsigned long e) //analysis cht(2)
  { JRLOCK__(p_); RETURN_OR_THROW(get_p()->get_edge(nid, e)); }

  bool save(std::string name, std::string arg1) //update broadcast
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->save(arg1)); }

  bool load(std::string name, std::string arg1) //update broadcast
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->load(arg1)); }

  std::map<std::string,std::map<std::string,std::string > > get_status(std::string name) //analysis broadcast
  { JRLOCK__(p_); RETURN_OR_THROW(p_->get_status()); }

  int create_node_here(std::string name, std::string nid) //update 
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->create_node_here(nid)); }

  int remove_global_node(std::string name, std::string nid) //update 
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->remove_global_node(nid)); }

  int create_edge_here(std::string name, unsigned long eid, edge_info ei) //update 
  { JWLOCK__(p_); RETURN_OR_THROW(get_p()->create_edge_here(eid, ei)); }
  int run(){ return p_->start(*this); };
  common::cshared_ptr<graph_serv> get_p(){ return p_->server(); };
private:
  common::cshared_ptr<server_helper<graph_serv> > p_;
};
}} // namespace jubatus::server
int main(int args, char** argv){
  return
    jubatus::framework::run_server<jubatus::server::graph_impl_,
                                   jubatus::server::graph_serv>
       (args, argv, "graph");
}
